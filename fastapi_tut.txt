FAST API tutorial

setup virtual environment
  C:\Users\ktchambers\AppData\Local\Programs\Python\Python312\python.exe -m venv env

setup requirements.txt file
  install fastapi
  install uvicorn[standard] //ASCII server used to serve our FAST API app
  
-base of app lives in main.py
-if use django, you would run py.manage.py_runserver
-instead, we will use uvicorn main:app
  ~main refers to the fact that we are calling main.py
  ~app refers to the fact that we call our app "app"
  ~a few flags we can pass in
    - --port= -> choose whatever port you want (5000, 3000, etc)
      ~default port is 8000
    - --reload -> dont want to hit ctrl+c+up_arrow+enter everytime we change something in the files
      ~looks for any changes saved in entire app. if something updates, it restarts the server 
-test on localhost:8000
-FASTAPI gives us a nice alternative to Postman because we cannot submit a post request from the browser
  ~swaggerdocs comes out of the box with FASTAPI
  ~we can execute CRUD requests from in here
  ~go to "localhost:8000/docs" for this feature
  
-Path Parameters
  ~if we were to localhost:8000/hello, we would get a message saying "{"detail": "not found"}"
  ~this value that we set as our endpoint, is called a path parameter in fast api
  ~if we want to add in functionality where we pass our path param in, wed do "@app.get("/items")"
  ~to get a specific item, your path param would be the id of the item object (ex: http://localhost:8000/items/5)
  ~ 
    @app.get("/items/{item_id}")
    async def get_item(item_id):
      return {"item_id": item_id}
  
  ~item_id shows as a string
  ~pydantic allows us to tell FAST API that we want out item_id to be an integer
    -"async def get_item(item_id: int):"
    -now the item_id is an integer -> "{"item_id":5}"
    -"hello" is not a valid integer (no shit)
    -removing the int tag from the function definition allows us to use hello as the tag
    -"{"item_id":"hello"}"
    -python 3.10-> is really good with type safety
    -if we refresh the documentaion, we can see the new routes we created
    -if we try to input an item id thats not an integer when we have the pydantics integer tag in the path param definition, we will get an error
  ~when building an app in FAST API, you want the user to be able to get informaition about themselves
  ~you generally dont want to unless they are an admin
  ~they shouldnt be able to just fetch a user by user_id unless you have a public profile situation of something like that
  ~
    @app.get("/users/{user_id}")
    async def get_user(user_id: str):
      return {"user_id": user_id}

    @app.get("/user/me")
    async def get_current_user():
      return {"message":"This is the current user"}
      
  ~FAST API hits the first route that qualifies
  ~we hit the "/users/{user_id}" route before the "/user/me" route because we are telling our app that the user_id is a string
  ~FAST API just goes through the list of routes
  ~if you want to allow a specific endpoint first ("/user/me") before a dynamic endpoint ("/users/{user_id}")
    -put it before the dynamic endpoint
    -
      @app.get("/users/me")
      async def get_current_user():
        return {"message":"This is the current user"}
        
      @app.get("/users/{user_id}")
      async def get_user(user_id: str):
        return {"user_id": user_id}

    -long story short ORDER MATTERS!!!
  ~specific types
    -
      class FoodEnum(str, Enum): # Instance will be a string because we declare a string Enum here
        fruits = "fruits"
        vegetables = "vegetables"
        dairy = "dairy"

    -if food_name == FoodEnum.vegetables:
      ~Check to see if food_name, which is a foodEnum, is a FoodEnum.vegetables object
    -if food_name.value == "fruits":
      ~Can instead check the value of the instance thats passed in
    -if neither are inputted as the path param, then it must be dairy, and we just return a third message
    -if no FoodEnum type is used as the path, we get a type error
      ~422 error: Unprocessable Entity

-Query Parameters
  ~any sort of tag you want to put at the end of your url
  ~allow for more dynamic searching on front end
  ~before, if you had a path parameter, that you declared here ->"@app.get("/users/{user_id}")"
  ~you then had to declare it here -> "async def get_user(user_id: str):" and FAST API would know to look for that path param
  ~a query parameter is an item hat you include in your function parameters that is not otherwise listed in the async line
  ~
    @app.get("/items")
    async def list_items(skip: int = 0, limit : int = 10):
      return fake_items_db[skip: skip + limit]

  ~by default, items returns everything
    -the skip integer = 0, so we wouldnt skip anything
    -the limit would be 10
    -if we were to say "http://localhost:8000/items?skip=1&limit=1"...
      ~knowing that our items database looks like {FOO, BAR, BAZ} 
      ~we would get BAR back
  ~optional parameters
    -this is if you want to have path and query parameters
    -FAST API knows that item_id is a path parameter because we declared it in the @app.get...
    -"async def get_item(item_id: str, q: str | None = None):"
      ~item_id=path param of type string; q=query parameter of type string or None, denoted by the union operator `|`
    -FAST API also knows that `q` is a query parameters because it is declaring it as a primitive type
    -if you pass something in  as a string, int, float, bool, or something, it will be a query parameter
  ~type conversion
    -
      faker = Faker()
      lorem_words = [faker.word() for _ in range(10)]
      lorem_description = " ".join(lorem_words)
      item = {"item_id": item_id}
      if q:
          #return {"item_id": item_id, "q": q }
          item.update({"q": q})
      if not short:
          item.update({"description": lorem_description})
      return item
      
    -the following returns a lorem ipsum description if a boolean parameter is true or false
    -the type conversion happens in the url
    -http://localhost:8000/items/hello?q=world&short=1 is the same as http://localhost:8000/items/hello?q=world&short=True
      ~we can also do true, on, and yes
      ~they all convert to a true situation    
  ~multiple path and query parameters
    -@app.get("/users/{user_id}/items/{item_id}")
    -Cannot have default params after non default params in func definition -> "q: str | None = None, short: bool"
    
  ~required query parameters
    -async def get_item(item_id: str, required_query_param: str , q: str | None = None, short: bool = False):
    -item = {"item_id": item_id, "required_query_param": required_query_param}
      ~ Demonstrates that you can have required query parameters
      
-Request Body
  ~what we would want to do if we were sending a post request, or a put/patch
  ~
    @app.post("/items")
    async def create_item():
      return item
      
  ~how would we pass in this information
  ~cant do it with a path parameter or query string
    -path parameter in url declaration
    -query string is primitive type not declared in url params
  ~we instead use pydantic
  ~from pydantic import BaseModel
  ~similar to a dictionary, we will declare the attributes for this class
  ~
    class Item(BaseModel): # dictionary, we will declare the attributes for this class
      name: str
      #description: Optional[str] = None
      description: str | None = None
      price: float
      tax: float | None = None 
  
  ~"async def create_item(item: str):"
    -looks like what we had before when we passed in a query string
    -this is because we are passing it in as a primitive type (ite,: str)
    -We can use the pydentic base model extension of item to tell FAST API that this is supposed to be a part of the request body that is being sent as a POST request
  ~"async def create_item(item: Item):"
    -
      {
        "name": "string",
        "description": "string",
        "price": 0,
        "tax": 0
      }
      
    -gives us a generic JSON object in the request body
    -since we declared the description and the tax optional, we can get rid of it
    -
      {
        "name": "string",
        "price": 0, <--- invalid JSON, trailing comma
      }
    
    -after we execute, we get the response body that we expect, with the description and tax equal to null
    -when getting rid of the price, we get a 422 error
    -"item_dict = item.dict()" -> Anything with a BaseModel, you can call the dict method on it and it will convert it into a dictionary
    -"item_dict = jsonable_encoder(item)" -> Strings for keys, any type for value, no longer an Item object
      ~"async def create_item(item: Item): -> Item" returns an error because we are no longer returning an item
      
-String Validation and Query Parameters
  ~the following code provides the request body below it
  
    @app.get("/items")
async def read_items(q: str | None = None):
    results = {"items": [{"items_id": "FOO"}, {"items_id": "BAR"}]}
    if q:
        results.update({"q":q})
    return results
  ------------------------------------------------------
    {
      "items": [
        {
          "items_id": "FOO"
        },
        {
          "items_id": "BAR"
        }
      ],
      "q": "foobar"
    }
    
  ~what if we wanted to set the limit of our query parameter to be 10 characters
    -foobar is six, foorbarfoobar wouldnt be an available query string in this case
  ~import and use Query object from fastapi package
  ~async def read_items(q: str | None = Query(None, min_length=3, max_length=10, regex="^fixedquery")):
    -allows us to set a min/max length
    -regex="^fixedquery" # This is the only thing thats allowed as our query, the word fixedquery
  ~async def read_items(q: str | None = Query("fixedquery", min_length=3, max_length=10)): 
    -allows us to set default query
  ~async def read_items(q: str = Query(..., min_length=3, max_length=10)): 
    -mequired query string. No default value, but it has to be something, validatiion
  ~async def read_items(q: list[str] | None = Query(None)): 
    -q=list allows for multiple entries Could be passing in multiple parameters, dont need to pass in anything
  ~query provides helpful error documentation on the client side
  ~we set default value of fixedquery, meaning that when you input nothing, you will still get back a result of "q":"fixedquery"
  ~@app.get('/items/hidden')
    -in "/items/{item_id}" this assumes that i should pass an item_query_parameter, i am not, so change the name
  ~async def hidden_query_route(hidden_query: str | None = Query(None, include_in_schema=False)): 
    -makes it so theres no actual param that shows up

-Numeric Validation and Path Parameters
  ~similar to query validation
  
-Multiple Parameters
  ~If you declare the base model and pass it into your path operation function
  ~It will recognize item as a request body parameter
  ~If we have multiple body parameters, we then have to declare them, in the request body
  ~"importance: int = Body(...)" # No need for nested dictionary
  ~we dont want to declare a whole BaseModel just to pass one parameter, use the Body object
  ~with `embed=True`, FastAPI wraps the parameter in another JSON object named after the parameter name. 
    -The `item` parameter would be wrapped in another JSON object named "item"
    -the item variable of type Item is no longer on the top level

-Body - Fields
  -Path, Query, Body objects allow us to declare meta data complex things
  -whether its a query param or we want an individual element ot be a body element
  -we dont have anything for generic types within our body element, until now
  -the Fields object is imported from pydantic, which extends fastapi
  -it allows you to attach metadata to elements in the body
  -"price: float = Field(..., gt=0, description="The price must be greater than zero")"
  
-Body - Nested Models
  -With FastAPI, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).
  -with list fields, you can define an attribute to be a subtype (ex: Python list)
  -ex: 
    class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    #tags: list = []
  
  -`tags` is now a list although it doesn't declare the type of the elements in the list
  -python has a specific way to declare lists with internal types or "type parameters"
  -"my_list: list[str] = []" # List declaration with a type parameter to make `my_list` a list of strings
  -tags shouldnt repear, they would prob be unique strings
    -python has a special data type for sets of unique items
    -we can declare tags as a set of strings
    -set_types: set[str] = set() # No repeating strings; ["fi", "fi"] only returns one "fi" in the response body
    -even when receiving a request w/ duplicate data, a unique set of items is always output
  -each attribute in a Pydantic model has a type
  -the type can itself be another Pydantic model
  -you can declare nested JSON "objects" with specific attribute names, types and validations.
  -this is all arbitrarily nested
  -ex:
    class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list = [] 
    image : Image | None = None
  
  -We can use the submodel as a type of an attribute
  -apart from normal types like str, int, float, etc. you can use more complex singular types that inherit from str.
  -multiple options in pydantic exotic types docs
  -ex: as in the image model we have a url field,
    -we can declare it to be an instance of pydantics Httpurl field instead of a string 
    -
      class Image(BaseModel):
        url: HttpUrl
        name: str
        
    -The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.
  -attributes with lists of submodels
  -you can also You can define arbitrarily deeply nested models:
  -
    {
      "name": "string",
      "description": "string",
      "price": 0,
      "items": [
        {
          "name": "string",
          "description": "string",
          "price": 0,
          "tax": 0,
          "tags": [],
          "images": [
            {
              "url": "https://example.com/",
              "name": "string"
            }
          ]
        }
      ]
    }
    
  -If the top level value of the JSON body you expect is a JSON array (a Python list),...
  -you can declare the type in the parameter of the Path operation function, the same as in Pydantic BaseModels
  -you can get editor support from everywhere, even for items inside of lists
  -You couldn't get this kind of editor support if you were working directly with dict instead of Pydantic models.
  -But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.
  -You can also declare a body as a dict with keys of some type and values of some other type.
  -*This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).
  
-Declare Request Example Data
  -You can declare examples of the data your app can receive.
  -Here are several ways to do it.
  -Extra JSON Schema data in Pydantic models
    -You can declare examples for a Pydantic model that will be added to the generated JSON Schema.
    -In Pydantic version 2, you would use the attribute model_config,
      -that takes a dict as described in Pydantic's docs: Model Config.
    - You can set "json_schema_extra" with a dict containing any additional data you would like to show up in the generated JSON Schema, 
      -including examples.
      -You could use the same technique to extend the JSON Schema and add your own custom extra info.
      -For example you could use it to add metadata for a frontend user interface, etc.
  -Field additional arguements
    -When using Field() with Pydantic models, you can also declare additional examples
      -name: str = Field(examples=["Foo"])
  -Body with multiple examples
    -OpenAPI specific examples
      -since before JSON schema supported "examples" OpenAPI had support for a different field called "examples"
      -this openapi specific examples goes in another section in the iopenapi specification
      -it goes in the details for each path operation, not inside each JSON schema
      -swagger UO has supported this examples field for a while
        -you can use it to show different examples in the docs UI
      -the shape of this openapi specific field examples is a dict with multiple examples instead of a list
        -each example has extra information that will be added to openapi
      -this doesnt go inside each JSON schema contained in Openapi, this goes outside, in the path operation directly
    -using the openapi_examples
      -declared in FASTAPI with the parameter openapi_examples for Path(), Query(), Body(), etc
    -*This old OpenAPI-specific examples parameter is now openapi_examples since FastAPI 0.103.0.

-Extra Data Types
  -youve used common primitive types
  -time for more complex data types
    -UUID
      -standard universally unique identifier -> common ID in many databases and systems
      -in request and response, will be represented as a str
    -datetime.datetime
      -python datetime.datetime
      -in requests and responses will be represented as a str in ISO 8601 format, (2008-09-15T15:53:00+05:00)
      -datetime.date -> 2008-09-15
      -datetime.time ->14:23:55.003
      -datetime.timedelta
    -frozenet
      -in requests, a list will be read, eliminating duplicates and converting it to a set
      -in response, the set will be converted to a list
      -the generated schema will specify that the set values are unique (using JSON schema's uniqueItems)
    -bytes
      -standard python bytes
      -requests and responses will be treated as str
      -the generated schema will specify that its a str with binary format
    -decimal
      -standard python decimal
      -in requests and responses, handled as a float
-cookie Parameters
  -You can define Cookie parameters the same way you define Body and Path parameters
  -"async def read_items(ads_id: Annotated[str | None, Cookie()] = None):"  Declare cookie parameters

-headder Parameters
  -You can define Header parameters the same way you define Query, Path and Cookie parameters.
  
-Response model
  -So far, we haven't told FASTAPI what the response model is, so it just shows us a string
  -documentaiton doesn't know what to expect for a successful response
  -After running, we see that we have the actual schema for a successful response
  -The response model is for documentation purposes
